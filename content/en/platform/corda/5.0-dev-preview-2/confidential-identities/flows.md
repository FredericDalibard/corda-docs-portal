---
date: '2020-09-10'
title: "Flows"
menu:
  corda-5-dev-preview:
    identifier: corda-5-dev-preview-1-confidential-identities-flows
    weight: 200
    parent: corda-5-dev-preview-1-confidential-identities
section_menu: corda-5-dev-preview

---
## RequestKeyFlow

As mentioned above, `RequestKeyFlow` can be run by calling initiating flows found in `InitiatingFlows.kt`. These flows are `RequestKey`, `RequestKeyForUUIDInitiator`, and `VerifyAndAddKey`.

`RequestKey` is used for requesting a new key from a counter-party. It has a single constructor which accepts a counter-party as a parameter.

`RequestKeyForUUIDInitiator` is used for requesting a new key from a counter-party and have that counter-party assign it to a specified account. It takes as its sole constructor the party from which to request a new key and a UUID representing an account id for the account hosted on the counter-party node.

`VerifyAndAddKey` has a single constructor which takes the counter-party to request a new key from and a public key to request an ownership claim for from that same counter-party. It is for requesting an ownership claim that the specified public key was generated by the node corresponding to the supplied party.

`RequestKeyFlow` takes as its constructor arguments the counter-party session we want to exchange confidential identities with initiated by one of the three flows mentioned above. It returns an anonymous party representing the counter-party. The three initiating flows mentioned above also return this same anonymous party.

`RequestKeyFlow` goes through the following key steps:

* Request a new key from the specified counter-party.
* The counter-party generates a new key-pair representing their own confidential identity.
* The counter-party signs this key and returns it to the initiating flow.
* The initiating flow verifies the signatures to ensure that identities were generated by the involved party.
* The key-party mapping is stored to be used as a confidential identity.
* An anonymous party is return by the flow representing the counter-party and the newly generated key.

This ensures not only that the confidential identity X.509 certificates are signed by the correct well-known identities, but also that the confidential identity private key is held by the counter-party, and that a party cannot claim ownership of another party’s confidential identities.


## SyncKeyMappingFlow

When constructing a transaction whose input states reference confidential identities, it is common for counterparties
to require knowledge of which well-known identity each confidential identity maps to. `SyncKeyMappingFlow` handles this
process. You can see an example of its use in `TwoPartyTradeFlow.kt`.

`SyncKeyMappingFlow` is divided into two parts:

* `SyncKeyMappingFlow`
* `SyncKeyMappingFlowHandler`

`SyncKeyMappingFlow` is invoked by the party initiating the identity synchronization. It could be called by a custom initiating flow, or it could be called via the initiating flow `SyncKeyMappingInitiator` found in `InitiatingFlows.kt`.

`SyncKeyMappingInitiator` must always be provided with the counter-party to synchronize well-known identities for confidential identities with. A wire transaction and/or a list of parties should also be passed to this flow. If a wire transaction is present, the flow will attempt to synchronize the confidential identities present in the transaction with the counter-party. If no wire transaction is provided but a list of parties is, then the flow will attempt to synchronize the confidential identities present in the list with the counter-party. If both are provided the wire transaction takes precedence.

The identity synchronization flow goes through the following key steps:

* Extract participant identities from all input and output states and remove any well known identities if using a transaction. Required signers on commands are currently ignored as they are presumed to be included in the participants on states, or to be well-known identities of services (such as an oracle service). If a list of parties is provided instead of a transaction, then this list is used.
* For each counter-party node, send a list of the public keys of the confidential identities, and receive back a list of those the counter-party needs the certificate path for
* Verify the requested list of identities contains only confidential identities in the offered list, and abort otherwise
* Send the requested confidential identities as a map of confidential identity public keys to well-known parties to the counter-party

{{< note >}}
`SyncKeyMappingFlow` works on a push basis. The initiating node can only send confidential identities it has
the X.509 certificates for, and the remote nodes can only request confidential identities being offered (are
referenced in the transaction passed to the initiating flow). There is no standard flow for nodes to collect
confidential identities before assembling a transaction, and this is left for individual flows to manage if
required.
{{< /note >}}

Meanwhile, `SyncKeyMappingFlowHandler` is invoked by all the other (non-initiating) parties involved in the identity synchronization process:

`SyncKeyMappingFlow` will serve all confidential identities in the provided transaction, irrespective of well-known identity. This is important for more complex transaction cases with 3+ parties, for example:

* Alice is building the transaction, and provides some input state *x* owned by a confidential identity of Alice
* Bob provides some input state *y* owned by a confidential identity of Bob
* Charlie provides some input state *z* owned by a confidential identity of Charlie

Alice may know all of the confidential identities ahead of time, but Bob does not know about Charlie’s and vice-versa. The assembled transaction therefore has three input states *x*, *y* and *z*, for which only Alice possesses certificates for all confidential identities. `SyncKeyMappingFlow` must send not just Alice’s confidential identity but also any other identities in the transaction to the Bob and Charlie.
